#!/usr/bin/env python3
import os
import subprocess
import json
import psutil
import platform
import pwd
import signal
from datetime import datetime
from typing import List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters

def verificar_root():
    """Verifica se o script est√° sendo executado como root"""
    if os.geteuid() != 0:
        print("‚ùå Este bot precisa ser executado como root!")
        exit(1)

# Verificar privil√©gios root
verificar_root()

# Carregar configura√ß√µes
try:
    with open('config.json', 'r') as f:
        config = json.load(f)
        TOKEN = config['token']
        DONO_USERNAME = config['dono_username']
        USUARIOS_AUTORIZADOS = config['usuarios_autorizados']
        TENTATIVAS_FALHAS = config.get('tentativas_falhas', {})
except Exception as e:
    print(f"Erro ao carregar configura√ß√µes: {e}")
    print("Execute o script de instala√ß√£o (install.py) primeiro!")
    exit(1)

# Limite de tentativas antes do bloqueio
MAX_TENTATIVAS = 7

def salvar_configuracoes():
    """Salva as configura√ß√µes atualizadas no arquivo"""
    with open('config.json', 'w') as f:
        json.dump({
            'token': TOKEN,
            'dono_username': DONO_USERNAME,
            'usuarios_autorizados': USUARIOS_AUTORIZADOS,
            'tentativas_falhas': TENTATIVAS_FALHAS
        }, f, indent=4)

def is_authorized(user_id: int, username: str = None) -> bool:
    """Verifica se o usu√°rio est√° autorizado e n√£o est√° bloqueado"""
    # Verificar se est√° bloqueado
    if username and username in TENTATIVAS_FALHAS:
        if TENTATIVAS_FALHAS[username] >= MAX_TENTATIVAS:
            return False
    
    # Verificar se √© autorizado
    return user_id in USUARIOS_AUTORIZADOS

def registrar_tentativa_falha(username: str):
    """Registra uma tentativa falha de acesso"""
    if not username:
        return
    
    username = username.lower()
    if username not in TENTATIVAS_FALHAS:
        TENTATIVAS_FALHAS[username] = 1
    else:
        TENTATIVAS_FALHAS[username] += 1
    
    salvar_configuracoes()

def is_owner(username: str) -> bool:
    """Verifica se o usu√°rio √© o dono do bot"""
    return username.lower() == DONO_USERNAME.lower()

COMANDOS_COMUNS = {
    "üìÇ Listar arquivos": "ls -la",
    "üíæ Uso do disco": "df -h",
    "üîÑ Uso da mem√≥ria": "free -h",
    "‚ö° Uso da CPU": "top -bn1 | head -n 5",
    "üì° Conex√µes de rede": "netstat -tuln",
    "üîç Processos ativos": "ps aux | head -n 5",
    "üë§ Usu√°rio atual": "whoami && id",
    "üìÖ Data e hora": "date",
    "üå°Ô∏è Temperatura CPU": "cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null || echo 'N√£o dispon√≠vel'",
    "üîí √öltimos logins": "last | head -n 5"
}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /start - Envia mensagem de boas-vindas com menu principal"""
    user_id = update.effective_user.id
    username = update.effective_user.username

    if not username:
        await update.message.reply_text(
            "‚ùå Voc√™ precisa ter um username configurado no Telegram para usar este bot."
        )
        return

    # Verificar se √© o dono
    if is_owner(username):
        # Resetar tentativas de falha se o dono acessar
        TENTATIVAS_FALHAS.clear()
        salvar_configuracoes()
    elif not is_authorized(user_id, username):
        # Registrar tentativa falha
        registrar_tentativa_falha(username)
        tentativas = TENTATIVAS_FALHAS.get(username, 0)
        
        if tentativas >= MAX_TENTATIVAS:
            await update.message.reply_text(
                "üö´ Acesso bloqueado devido a m√∫ltiplas tentativas n√£o autorizadas.\n"
                "Entre em contato com o administrador do sistema."
            )
        else:
            await update.message.reply_text(
                f"‚ùå Acesso n√£o autorizado!\n"
                f"Tentativas restantes: {MAX_TENTATIVAS - tentativas}"
            )
        return

    # Mensagem de boas-vindas detalhada
    welcome_message = f"""
ü§ñ *Bem-vindo ao Terminal Bot!*

Este bot permite controlar seu servidor via Telegram com privil√©gios root.

*Informa√ß√µes do Sistema:*
‚Ä¢ Sistema: {platform.system()} {platform.release()}
‚Ä¢ Hostname: {platform.node()}
‚Ä¢ Python: {platform.python_version()}
‚Ä¢ Bot Version: 1.0

*Comandos Dispon√≠veis:*
üìå *B√°sicos:*
‚Ä¢ /start - Mostra esta mensagem
‚Ä¢ /help - Mostra ajuda detalhada
‚Ä¢ /status - Status do sistema

üõ†Ô∏è *Terminal:*
‚Ä¢ /cmd <comando> - Executa comando
Exemplo: `/cmd ls -la`

‚ö° *Comandos R√°pidos:*
‚Ä¢ Use o menu abaixo para acessar

‚ö†Ô∏è *Seguran√ßa:*
‚Ä¢ Todos os comandos s√£o executados como root
‚Ä¢ Todas as a√ß√µes s√£o registradas
‚Ä¢ {MAX_TENTATIVAS} tentativas falhas = bloqueio
‚Ä¢ Apenas o dono pode desbloquear usu√°rios

*Status do Usu√°rio:*
‚Ä¢ Nome: {update.effective_user.first_name}
‚Ä¢ Username: @{username}
‚Ä¢ ID: `{user_id}`
‚Ä¢ N√≠vel: {"üëë Dono" if is_owner(username) else "üë§ Autorizado"}

Use os bot√µes abaixo para come√ßar:
"""

    keyboard = [
        [InlineKeyboardButton("üìä Status do Sistema", callback_data='status')],
        [InlineKeyboardButton("‚ö° Comandos R√°pidos", callback_data='quick_commands')],
        [InlineKeyboardButton("‚ùì Ajuda Detalhada", callback_data='help')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        welcome_message,
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /help - Mostra todos os comandos dispon√≠veis"""
    if not is_authorized(update.effective_user.id):
        await update.message.reply_text("‚ùå Desculpe, voc√™ n√£o est√° autorizado a usar este bot.")
        return
    
    help_text = """
ü§ñ *Comandos Dispon√≠veis*

B√°sicos:
/start - Inicia o bot e mostra o menu principal
/help - Mostra esta mensagem de ajuda
/status - Mostra status do sistema

Comandos do Terminal:
/cmd <comando> - Executa um comando no terminal
Exemplo: `/cmd ls -la`

Comandos R√°pidos:
/disk - Mostra uso do disco
/mem - Mostra uso da mem√≥ria
/cpu - Mostra uso da CPU
/net - Mostra conex√µes de rede
/ps - Lista processos ativos

‚ö†Ô∏è *Observa√ß√µes*:
- Apenas usu√°rios autorizados podem usar o bot
- Alguns comandos podem levar alguns segundos para responder
- Use com responsabilidade!
"""
    await update.message.reply_text(help_text, parse_mode='Markdown')

async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /status - Mostra informa√ß√µes do sistema"""
    if not is_authorized(update.effective_user.id):
        await update.message.reply_text("‚ùå Desculpe, voc√™ n√£o est√° autorizado a usar este bot.")
        return
    
    # Coleta informa√ß√µes do sistema
    cpu_percent = psutil.cpu_percent(interval=1)
    mem = psutil.virtual_memory()
    disk = psutil.disk_usage('/')
    boot_time = datetime.fromtimestamp(psutil.boot_time()).strftime("%Y-%m-%d %H:%M:%S")
    
    status_text = f"""
üñ•Ô∏è *Status do Sistema*

*Sistema:*
OS: {platform.system()} {platform.release()}
Uptime desde: {boot_time}

*Recursos:*
CPU: {cpu_percent}%
RAM: {mem.percent}% usado
Disco: {disk.percent}% usado

*Mem√≥ria:*
Total: {bytes_to_human(mem.total)}
Usado: {bytes_to_human(mem.used)}
Livre: {bytes_to_human(mem.free)}

*Disco:*
Total: {bytes_to_human(disk.total)}
Usado: {bytes_to_human(disk.used)}
Livre: {bytes_to_human(disk.free)}
"""
    await update.message.reply_text(status_text, parse_mode='Markdown')

async def quick_commands_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra menu de comandos r√°pidos"""
    keyboard = []
    for comando_nome in COMANDOS_COMUNS.keys():
        keyboard.append([InlineKeyboardButton(comando_nome, callback_data=f'cmd_{comando_nome}')])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "üìù Selecione um comando r√°pido:",
        reply_markup=reply_markup
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manipula callbacks dos bot√µes"""
    query = update.callback_query
    await query.answer()
    
    if not is_authorized(query.from_user.id):
        await query.message.reply_text("‚ùå Desculpe, voc√™ n√£o est√° autorizado a usar este bot.")
        return
    
    if query.data == 'status':
        await status_command(query, context)
    elif query.data == 'quick_commands':
        await quick_commands_menu(query, context)
    elif query.data == 'help':
        await help_command(query, context)
    elif query.data.startswith('cmd_'):
        comando_nome = query.data[4:]
        comando = COMANDOS_COMUNS.get(comando_nome)
        if comando:
            context.user_data['command'] = comando
            await execute_command(query, context)

async def execute_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Executa o comando recebido no terminal com privil√©gios root"""
    if not is_authorized(update.effective_user.id):
        await update.message.reply_text("‚ùå Desculpe, voc√™ n√£o est√° autorizado a usar este bot.")
        return

    # Obt√©m o comando
    if isinstance(update, Update):
        command = update.message.text[5:].strip()  # Remove '/cmd '
    else:
        command = context.user_data.get('command', '')

    if not command:
        await update.message.reply_text("‚ùå Por favor, especifique um comando para executar.")
        return

    try:
        # Garantir que o comando seja executado como root
        if os.geteuid() != 0:
            command = f"sudo {command}"

        # Registrar comando no log do sistema
        log_command = f"Comando executado via Telegram Bot por ID {update.effective_user.id}: {command}"
        subprocess.run(['logger', '-t', 'telegram-bot', log_command])

        process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            preexec_fn=os.setsid  # Criar novo grupo de processo
        )
        
        try:
            stdout, stderr = process.communicate(timeout=60)  # Timeout de 60 segundos
        except subprocess.TimeoutExpired:
            os.killpg(os.getpgid(process.pid), signal.SIGTERM)
            await update.message.reply_text("‚ö†Ô∏è Comando cancelado: tempo limite excedido (60s)")
            return

        response = f"üîß *Comando executado como root:* `{command}`\n\n"
        if stdout:
            response += f"üì§ *Sa√≠da:*\n```\n{stdout[:1500]}```\n"  # Limitar sa√≠da
            if len(stdout) > 1500:
                response += "\n... (sa√≠da truncada) ...\n"
        if stderr:
            response += f"‚ö†Ô∏è *Erro:*\n```\n{stderr[:500]}```\n"  # Limitar erros
            if len(stderr) > 500:
                response += "\n... (mensagem de erro truncada) ...\n"
        if not stdout and not stderr:
            response += "‚úÖ Comando executado sem sa√≠da."

        # Divide a resposta se for muito longa
        if len(response) > 4000:
            for i in range(0, len(response), 4000):
                await update.message.reply_text(
                    response[i:i+4000],
                    parse_mode='Markdown'
                )
        else:
            await update.message.reply_text(response, parse_mode='Markdown')

    except Exception as e:
        error_msg = f"‚ùå Erro ao executar o comando: {str(e)}"
        await update.message.reply_text(error_msg)
        # Registrar erro no log do sistema
        subprocess.run(['logger', '-t', 'telegram-bot', f"Erro: {error_msg}"])

def bytes_to_human(bytes_value):
    """Converte bytes para formato leg√≠vel"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_value < 1024:
            return f"{bytes_value:.2f} {unit}"
        bytes_value /= 1024
    return f"{bytes_value:.2f} PB"

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manipula erros do bot"""
    print(f"Erro: {context.error}")
    await update.message.reply_text("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.")

def main():
    """Fun√ß√£o principal"""
    if not USUARIOS_AUTORIZADOS:
        print("‚ö†Ô∏è AVISO: Nenhum usu√°rio autorizado configurado!")
        print("Execute o script de instala√ß√£o (install.py) para configurar o bot.")
        return

    # Cria o aplicativo
    app = Application.builder().token(TOKEN).build()

    # Adiciona os handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("status", status_command))
    app.add_handler(CommandHandler("cmd", execute_command))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_error_handler(error_handler)

    # Inicia o bot
    print("ü§ñ Bot iniciado! Pressione Ctrl+C para parar.")
    app.run_polling(poll_interval=1)

if __name__ == "__main__":
    main() 